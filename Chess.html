<head>
	<script>
		if (window.location.protocol === "file:") {
			var debug = true
		} else {
			var debug = false
		}
		var alerts = false
		var board = []
		for(let i = 0; i < 9; i++){
			temp = []
			for(let j = 0; j < 9; j++){
				temp.push("")
			}
			board.push(temp)
		}
			whiteTurn = 1
		if(debug){
			console.warn("debug mode/dev tools are on")
			function override(X,Y,piece,team){
				if((piece == null)||(team == null)){
					board[X][Y] = new square
				}
				else{
					board[X][Y] = new piece(team)
				}
				if(debug){console.log("piece at (" + X + "," + Y + ") changed")}
			}
			function clear(){
				if(debug){console.log("clearing")}
				for(let i = 0; i < 8; i++){
					for(let j = 0; j < 8; j++){
						board[i][j] = new square
					}
				}
			}
		}
		//function created by chatGPT, modified to work with classes
		function deepCopy3DArray(arr) {
			return arr.map(function(layer) {
				return layer.slice();
			});
		}
		function reset(logReset) {
			if(logReset){
				log = []
			}
			if(debug){console.log("resetting")}
			for(let i = -1; i < 2; i += 2){
				if(debug){console.log("drawing for team " + i)}
				for(let j = 0; j < 2; j++){
					board[j*7][((i-1)/-2)*7] = new rook(i)
					board[(j*5)+1][((i-1)/-2)*7] = new knight(i)
					board[(j*3)+2][((i-1)/-2)*7] = new bishop(i)
				}
				board[3][((i-1)/-2)*7] = new queen(i)
				board[4][((i-1)/-2)*7] = new king(i)
				if(debug){console.log("rear row for team " + i + " done")}
				//rear rows^^^
					for(let x = 0; x < 8; x++){
						board[x][(((i*-1)+1)*2.5)+1] = new pawn(i)

					}
				if(debug){console.log("pawns for team " + i + " done")}
				//pawn rows^^^
			}
			for(let j = 2; j < 6; j++){
				for(let i = 0; i < 8; i++){
					board[i][j] = new square
				}
			}
			if(debug){console.log("empty rows complete")}
			whiteTurn = 1
			if(debug){console.log("turn reset")}
			moved = [false, false, false, false, false, false]
			if(debug){console.log("castle prereq reset")}
		}
		function RBQ(beginX, beginY, endX, endY, x, y, piece){
			beginX = parseInt(beginX)
			beginY = parseInt(beginY)
			endX = parseInt(endX)
			endY = parseInt(endY)
			x = parseInt(x)
			y = parseInt(y)
			if(debug){console.log(""+beginX+beginY+endX+endY+x+y)}
			end = false
			count = 1
			while(end==false){
				end = false
				if(debug){
					console.log("count = " + (count))
					console.log("end true")
					console.log("current square contains "+ board[beginX+(x*count)][beginY+(y*count)].piece)
				}
				if(((beginX+(x*count)) == endX)&&(beginY+(y*count)) == endY){
					if(debug){console.log("End reached/completing move")}
					board[beginX][beginY] = new square
					board[endX][endY] = new piece(whiteTurn)
					if(debug){console.log("move done")}
					if(piece == rook){
						board[endX][endY].moved = true
					}
					return(true)
				}
				if(board[beginX+(x*count)][beginY+(y*count)][1] == whiteTurn){
					if(debug){console.log("attempted friendly noclip")}
					if(alerts){alert("you can't move through your own pieces")}
					end = true
					
				}
				if(board[beginX+(x*count)][beginY+(y*count)][1] == (-1*whiteTurn)){
					end = true
					if(debug){console.log("attempted enemy noclip")}
					if(alerts){alert("you can't move through enemy pieces")}
				}
			count += 1
			}
		}
		class square {
			constructor(){
				this.team = 0
				this.piece = 'square'
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(){
				console.log('attempted movement of nothing')
				if(alerts){alert("you think you're funny, don't you")}
			}
		}
		class pawn {
			constructor(team){
				this.team = team
				this.piece = "pawn"
				this.doubleMoved = false
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(beginX, beginY, endX, endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log("pawn selected")}
				if((endX == beginX - 1)&&(endY == beginY + this.team)){
					if(debug){console.log('attempted diagonal movement left')}
					if(endX == beginX - 1) {
						if(debug){console.log("attempted to attack left")}
						if((board[endX][beginY].piece == "pawn")&&(board[endX][beginY].team == (-1*whiteTurn))){
							if(debug){console.log("attempted en passant")}
							if(board[endX][beginY].doubleMoved == true){
								if(debug){console.log('enemy piece double moved')}
								if(board[endX][endY].piece == "square"){
									if(debug){console.log('destination is clear')}
									if(debug){console.log("valid en passant")}
									board[beginX][beginY] = new square
									board[endX][endY] = new pawn(whiteTurn)
									board[endX][beginY] = new square
									if(debug){console.log("move done")}
									return(true)
								}
							}
						}
						else if(board[endX][endY].team == (-1*this.team)){
							if(debug){console.log('valid attack left')}
							board[beginX][beginY] = new square
							board[endX][endY] = new pawn(this.team)
							return(true)
						}
						else{if(alerts){alert("pawns can only ATTACK diagonally")}}
					}
				}
				else if(endX == beginX + 1){
					if(debug){console.log("attempted attack right")}
					if((board[endX][beginY].piece == "pawn")&&(board[endX][beginY].team == (-1*whiteTurn))){
						if(debug){console.log("attempted en passant")}
						if(board[endX][beginY].doubleMoved == true){
							if(debug){console.log('enemy piece double moved')}
							if(board[endX][endY].piece == "square"){
								if(debug){console.log('destination is clear')}
								if(debug){console.log("valid en passant")}
								board[beginX][beginY] = new square
								board[endX][endY] = new pawn(whiteTurn)
								board[endX][beginY] = new square
								if(debug){console.log("move done")}
								return(true)
							}
						}
					}
				}
				if((board[endX][endY].team == (-1*whiteTurn))&&(((endX == beginX - 1)||(endX == beginX + 1))&&(endY == beginY + whiteTurn))){
					board[endX][endY] = new pawn(whiteTurn)
					board[beginX][beginY] = new square
					if(debug){"attack right verified/move done"}
					return(true)
				}
				else if((endY == beginY + whiteTurn)&&(endX == beginX)){//checks if you are trying to move one forward
					if(debug){console.log("attempted move forward")}
					if(board[endX][endY].piece == 'square'){
						board[endX][endY] = new pawn(whiteTurn)
						board[beginX][beginY] = new square
						if(debug){console.log("move verified/move done")}
						return(true)
					}
					else{if(alerts){alert("pawns can only MOVE forward")}}
				}
				if((endY == beginY + (2*whiteTurn))&&(endX == beginX)){
					if(debug){console.log("attempting move two forward")}
					if(board[beginX][beginY+whiteTurn].piece == "square"){
						if(board[beginX][beginY+(2*whiteTurn)].piece == "square"){
							if(debug){console.log("double move step 1 validated")}
								if(((whiteTurn == 1)&&(beginY==1))||((whiteTurn == -1)&&(beginY==6))){
								if(debug){console.log("double move step 2 validated")}
								board[beginX][beginY] = new square
								board[endX][endY] = new pawn(whiteTurn)
								board[endX][endY].doubleMoved = true
								return(true)
							}
							else {
							console.log('failed double move(attempted move outside pawn start)')
							if(alerts){alert('pawns can only double move from their starting row')}
							}
						}
						else {
							console.log('failed double move(attempted capture w/ move)')
							if(alerts){alert('pawns can only move forward')}
						}
					}
					else {
						console.log('failed double move(attempted move over piece)')
						if(alerts){alert("when double moving, you can't go over pieces")}
					}
				}
				else{if(alerts){alert("move the pawn like a pawn")}}
			}
		}
		class knight {
			constructor(team){
				this.team = team
				this.piece = "knight"
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(beginX,beginY,endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log("knight selected")}
				if((endX == beginX-2)||(endX == beginX+2)){
					if(debug){console.log("far left/right movement area selected")}
					if((endY == beginY+1) || (endY == beginY-1)){
						board[endX][endY] = new knight(whiteTurn)
						board[beginX][beginY] = new square
						if(debug){console.log("move verified/move done")}
						return(true)
					}
				}
				if((endX == beginX-1)||(endX == beginX+1)){
					if(debug){console.log("near left/right movement area selected")}
					if((endY == beginY+2)||(endY == beginY-2)){
						board[endX][endY] = new knight(whiteTurn)
						board[beginX][beginY] = new square
						if(debug){console.log("move verified/move done")}
						return(true)
					}
				}
				else{if(alerts){alert("move the knight like a knight")}}
			}
		}
		class rook {
			constructor(team,moved){
				this.team = team
				this.piece = "rook"
				this.frozen = 0
				this.mortal = true
				if(moved == null){
					this.moved = false
				}
				else{this.moved = moved}
			}
			tick(){}
			move(beginX,beginY,endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log("rook selected")}
				if(endX == beginX){//if it is moving on the x axis
					if(debug){console.log("Y axis moving")}
					if(endY > beginY){//if it is moving left
						if(debug){console.log("moving forward")}
						return(RBQ(beginX,beginY,endX,endY,0,1,rook))
					}
					else{
						if(debug){console.log("moving backwards")}
						return(RBQ(beginX,beginY,endX,endY,0,-1,rook))
					}
				}
				else if(endY == beginY){//if it is moving on the x axis
					if(beginX < endX){//if it is moving down
						if(debug){console.log("moving left")}
						return(RBQ(beginX,beginY,endX,endY,1,0,rook))
					}
					else{
						if(debug){console.log("moving right")}
						return(RBQ(beginX,beginY,endX,endY,-1,0,rook))
					}
				}
				else{if(alerts){alert("move a rook like a rook")}}
			}
		}
		class king {
			constructor(team,moved){
				this.team = team
				this.piece = "king"
				this.frozen = 0
				this.mortal = true
				if(moved == null){
					this.moved = false
				}
				else{this.moved = moved}
			}
			tick(){}
			move(beginX,beginY,endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if((endX > beginX-2)&&(endX < beginX+2)){
					if(debug){console.log('valid x position')}
					if((endY > beginY-2)&&(endY < beginY+2)){
						if(debug){console.log('valid y position')}
						board[endX][endY] = new king(whiteTurn,true)
						board[beginX][beginY] = new square
						if(debug){console.log('move done')}
						return(true)
					}
					else{if(alerts){alert("the king can ONLY move in a three by three area around it")}}
				}
				else{if(alerts){alert("the king can ONLY move in a three by three area around it")}}
			}
		}
		class bishop {
			constructor(team){
				this.team = team
				this.piece = "bishop"
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(beginX,beginY,endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log("bishop selected")}
				if(Math.abs(endX-beginX) == Math.abs(endY-beginY)){
					if(debug){console.log("step 1 valid")}
					if(endY > beginY){
						if(debug){console.log("moving right")}
						if(endX > beginX){
							if(debug){console.log("moving down")}
							return(RBQ(beginX,beginY,endX,endY,1,1,bishop))
						}
						else{
							if(debug){console.log("moving up")}
							return(RBQ(beginX,beginY,endX,endY,-1,1,bishop))
						}
					}
					else{
						if(debug){console.log("moving left")}
						if(endX > beginX){
							if(debug){console.log("moving down")}
							return(RBQ(beginX,beginY,endX,endY,1,-1,bishop))
						}
						else{
							if(debug){console.log("moving up")}
							return(RBQ(beginX,beginY,endX,endY,-1,-1,bishop))
						}
					}
				}
			}
		}
		class queen {
			constructor(team){
				this.team = team
				this.piece = "queen"
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(beginX,beginY,endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log("queen selected")}
				if(Math.abs(endX-beginX) == Math.abs(endY-beginY)){
					if(debug){console.log("step 1 valid")}
					if(endY > beginY){
						if(debug){console.log("moving right")}
						if(endX > beginX){
							if(debug){console.log("moving down")}
							return(RBQ(beginX,beginY,endX,endY,1,1,queen))
						}
						else{
							if(debug){console.log("moving up")}
							return(RBQ(beginX,beginY,endX,endY,-1,1,queen))
						}
					}
					else{
						if(debug){console.log("moving left")}
						if(endX > beginX){
							if(debug){console.log("moving down")}
							return(RBQ(beginX,beginY,endX,endY,1,-1,queen))
						}
						else{
							if(debug){console.log("moving up")}
							return(RBQ(beginX,beginY,endX,endY,-1,-1,queen))
						}
					}
				}
				else if((beginX == endX)||(beginY == endY)){
					if(endX == beginX){//if it is moving on the x axis
						if(debug){console.log("X axis movement selected")}
						if(endY > beginY){//if it is moving left
							if(debug){console.log("moving up")}
							return(RBQ(beginX,beginY,endX,endY,0,1,queen))
						}
							else{
							if(debug){console.log("moving down")}
							return(RBQ(beginX,beginY,endX,endY,0,-1,queen))
						}
					}
					else if(endY == beginY){//if it is moving on the x axis
						if(beginX < endX){//if it is moving down
							if(debug){console.log("moving left")}
							return(RBQ(beginX,beginY,endX,endY,1,0,queen))
						}
					else{
							if(debug){console.log("moving right")}
							return(RBQ(beginX,beginY,endX,endY,-1,0,queen))
						}
					}
				}
				else{if(alerts){alert("move the queen like a queen")}}
			}
		}
		class circus{
			constructor(team,x,y){
				this.team = team
				this.piece = "circus"
				this.x = x
				this.y = y
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				if(debug){console.log('attempted circus move')}
				if((Math.abs(endX-this.x)) < 2){
					if(debug){console.log('x axis good')}
					if((Math.abs(endY-this.y)) < 2){
						if(debug){console.log('y axis good')}
						if((this.x == endX)||(this.y == endY)){
							if(debug){console.log('direction good')}
							let out = false
							if(board[endX][endY].team == 0){
								out = true
							}
							board[endX][endY] = new circus(this.team,endX,endY)
							board[this.x][this.y] = new square
							return(out)
						}
					}
				}
			}
		}
		class wizard{
			constructor(team,x,y){
				this.team = team
				this.piece = "wizard"
				this.x = x
				this.y = y
				this.frozen = 0
				this.mortal = true
			}
			tick(){}
			move(endX,endY){
				if(!(this.frozen == false)){
					if(debug){console.log('attempted frozen move')}
					return(false)
				}
				var attempt = prompt('what do you want to do? move/freeze/teleport')
				if(attempt == 'move'){
					if(board[endX][endY].piece == "square"){
						if((Math.abs(endX-this.x)) < 2){
							if(debug){console.log('x axis good')}
							if((Math.abs(endY-this.y)) < 2){
								if(debug){console.log('y axis good')}
								board[endX][endY] = new wizard(this.team,endX,endY)
								board[this.x][this.y] = new square
								return(true)
							}
						}
					}
				}
				else if(attempt == 'freeze'){
					board[endX][endY].frozen = 4
					board[this.x][this.y] = new pawn(this.team)
					return(true)
				}
				else if(attempt == 'teleport'){
					if(board[endX][endY].piece = 'square'){
						board[this.x][this.y] = new square
						board[endX][endY] = new pawn(this.team)
						return(true)
					}
				}
			}
		}
		class paladin{
			constructor(team,x,y){
				this.team = team
				this.piece = "paladin"
				this.x = x
				this.y = y
				this.frozen = 0
				this.mortal = true
			}
			move(endX,endY){
				if((Math.abs(endX-this.x)) < 2){
					if(debug){console.log('x axis good')}
					if((Math.abs(endY-this.y)) < 2){
						if(debug){console.log('y axis good')}
						board[endX][endY] = new paladin(this.team,endX,endY)
						board[this.x][this.y] = new square
						return(true)
					}
				}
			}
			tick(){
				if(whiteTurn == this.team){
					this.mortal = false
				}
			}
		}
		function move(beginX, beginY, endX, endY) {
			beginX = parseInt(beginX)
			beginY = parseInt(beginY)
			endX = parseInt(endX)
			endY = parseInt(endY)
			if(debug){console.log("move", beginX, beginY, endX, endY)}
			if(board[beginX][beginY] == null) {
				if(alerts){alert("you can't move a non-existant piece")}
			}
			else if(board[beginX][beginY].team == (-1*whiteTurn)){//cheat prevention
				if(alerts){alert("you can't move enemy pieces")}
			}
			else if((endX == beginX)&&(endY == beginY)){//makes sure the start and end aren't the same
				if(alerts){alert("you have to actually move the piece")}
			}
			else if(board[endX][endY].mortal == false){
				if(debug){console.log('attempted immortal kill')}
				if(alerts){alert("can't kill the immortal")}
			}
			else if(board[endX][endY].team == whiteTurn){
				if(board[beginX][beginY].piece == "rook"){
					if(board[endX][endY].piece == "king"){
						if(debug){console.log("attempted castle")}
						if((beginX == 0)||(beginX == 7)){
							if(debug){console.log("back row")}
							if((beginY == 0)||(beginY == 7)){
								if(board[endX][endY].moved == false){
									if(debug){console.log("king hasn't moved")}
									if(board[beginX][beginY].moved == false){
										if(debug){console.log("pieces haven't moved")}			
										var valid = true
										if(debug){console.log("starting empty check")}
										var count = 1
										if(beginX == 0){
											if(debug){console.log("left side")}
											while((count < 4)&&(valid)){
												if(debug){
													console.log("checking " + count)
												}
												if(!(board[count][beginY].piece == "square")){valid = false}
												if(debug){console.log(valid)}
												count++
											}
										}
										else{
											if(debug){console.log("right side")}
											while((count < 3)&&(valid)){
												if(debug){
													console.log("checking " + count)
												}
												if(!(board[7-count][beginY].piece == "square")){valid = false}
												if(debug){console.log(valid)}
												count++
											}
										}
									}
									else{
										if(debug){console.log("pieces have moved")}
										if(alerts){alert("invalid castle")}
										return(false)
									}
								}
								if(valid){
									if(debug){console.log("it worked")}
									board[beginX][endY] = new square
									board[endX][endY] = new square
									if(debug){console.log("pieces cleared")}
									board[Math.abs((beginX)-1)][beginY] = new king(whiteTurn,true)
									board[Math.abs((beginX)-2)][beginY] = new rook(whiteTurn,true)
									return(true)
								}
							}
						}
					}
				}
				else{if(alerts){alert("You can't capture your own pieces")}}
			}
			else if(board[beginX][beginY].piece == "pawn") {
				if(board[beginX][beginY].move(beginX,beginY,endX,endY)){
					if(endY == ((whiteTurn+1)*3.5)){
						var valid = ["knight", "rook", "bishop", "queen", "circus", "wizard"]
						do {
							if(debug){console.log("attempting input")}
							var input = prompt("What would you like the promoted pawn to be?")
						}
						while(!(valid.includes(input)))
						if(debug){console.log("input valid")}
						if(input == "knight"){input = knight}
						else if(input == "rook"){input = rook}
						else if(input == "bishop"){input = bishop}
						else if(input == "queen"){input = queen}
						else if(input == "circus"){input = circus}
						else if(input == "wizard"){input = wizard}
						else{console.error("promotion input change error")}
						board[endX][endY] = new input(whiteTurn,endX,endY)
						if(debug){console.log("Promotion done")}
					}
					return(true)
				}
			}
			else if(board[beginX][beginY].piece == "knight"){
				return(board[beginX][beginY].move(beginX,beginY,endX,endY))
			}
			else if(board[beginX][beginY].piece == "rook"){
				return(board[beginX][beginY].move(beginX,beginY,endX,endY))
			}
			else if(board[beginX][beginY].piece == "king"){
				return(board[beginX][beginY].move(beginX,beginY,endX,endY))
			}
			else if(board[beginX][beginY].piece == "bishop"){
				return(board[beginX][beginY].move(beginX,beginY,endX,endY))
			}
			else if(board[beginX][beginY].piece == "queen"){
				return(board[beginX][beginY].move(beginX,beginY,endX,endY))
			}
			else if(board[beginX][beginY].piece == "circus"){
				return(board[beginX][beginY].move(endX,endY))
			}
			else if(board[beginX][beginY].piece == "wizard"){
				return(board[beginX][beginY].move(endX,endY))
			}
			else if(board[beginX][beginY].piece == "paladin"){
				return(board[beginX][beginY].move(endX,endY))
			}
			return(false)
		}
		function endcheck() {
			var whiteKing = false
			var blackKing = false
			if(debug){console.log("begining check for if a king is alive")}
			for(let i = 0; i < 8; i++){
				for(let j = 0; j < 8; j++){
					if(board[i][j].piece == "king") {
						if(board[i][j].team == 1) {
							whiteKing = true
							if(debug){console.log("white king found")}
						}
						if(board[i][j].team == -1) {
							blackKing = true
							if(debug){console.log("black king found")}
						}					
					}
				}
			}
			if(whiteKing == false){
				if(whiteKing == blackKing){
					console.error("both kings are dead")
					if(alerts){alert("contrats! you broke my game!")}
				}
				else{
					if(debug){console.log("black victory")}
					if(alerts){alert("black wins!")}
					reset(true)
					return(false)
				}
			}
			else if(blackKing == false){
				if(debug){console.log("white victory")}
				if(alerts){alert("white wins!")}
				reset(true)
				return(false)
			}
			else {
				return(true)
				if(debug){console.log("both kings are alive")}
			}
		}
		var turn = 0
		var log = []
		var moveLog = []
		function logger(toLog){
			if(toLog == null){
				log.push(deepCopy3DArray(board))
				turn += 1
				if(debug){console.log("saving board")}
			}
			else{
				board = [...log[toLog]]
				turn = toLog
				if(turn%2 == 0){
					whiteTurn = -1
				}
				if(debug){console.log("loading board")}
			}
		}
		function undo(){
			logger(log.length-2)
		}
		function graphicStart(X,Y,x,y) {
			if(debug){
				console.log("coord 1 is "+X+Y)
				console.log("coord 2 is "+x+y)
			}
			failed = false
			failed = (!(move(X,Y,x,y)))
			if(debug){console.log("movement done")}
			if(!(failed)){
				for(let i = 0; i < 8; i++){
					for(let j = 0; j < 8; j++){
						if(board[i][j].frozen > 0){
							board[i][j].frozen -= 1
						}
						board[i][j].tick()
					}
				}
				whiteTurn *= -1
				if(!(endcheck())){
					if(debug){console.log("resetting")}
					reset(true)
					graphicDraw()
				}
				if(debug){console.log("continuing game")}
				logger()
			}
			graphicDraw()
		}
	</script>
</head>
<body id:body;>
	<div id="test" class="grid-container"></div>
	<style>
		.grid-container {
			display:grid;
			grid-template-columns:auto auto auto auto auto auto auto auto;
			justify-content:center;
			margin: 0;
			position: absolute;
			top: 50%;
			left: 50%;
			-ms-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
		}
	</style>
	<script>
		var clickPos = [0,0]
		var firstClick = true
		if(window.innerWidth < window.innerHeight){
			size = window.innerWidth-20
		}
		else{
			size = window.innerHeight-20
		}
		for(let i = 7; i > -1; i--){
			for(let j = 0; j < 8; j++){
				var buttonShort = document.createElement("button");
				var test = document.getElementById("test");
				buttonShort.className = "grid-item"
				buttonShort.setAttribute("id", ("" + j) + i)
				buttonShort.style.width = ((size/8)+"px")
				buttonShort.style.height = ((size/8)+"px")
				buttonShort.dataset.x = j
				buttonShort.dataset.y = i
				buttonShort.style.fontSize = size/10
				buttonShort.innerHTML = (("" + j) + i)
				test.appendChild(buttonShort);
				buttonShort.addEventListener('mousedown', function(){
					clickPos[0] = this.dataset.x
					clickPos[1] = this.dataset.y
					if(debug){console.log("first click was at " + clickPos[0] + clickPos[1])}
				})
				buttonShort.addEventListener('mouseup', function(){
					if(debug){console.log('second click was at ' + this.dataset.x + this.dataset.y)}
					graphicStart(clickPos[0],clickPos[1],(this.dataset.x),(this.dataset.y))
				})
			}
		}
		//9812 white king
		//9813 White queen
		//9814 White rook
		//9815 White bishop
		//9816 White knight
		//9817 White pawn
		//9828 White Circus
		//9818 Black king
		//9819 Black queen
		//9820 Black rook
		//9821 Black bishop
		//9822 Black knight
		//9823 Black pawn
		//9824 Black Curcus
		function graphicDraw(){
			for(let i = 0; i < 8; i++){
				for(let j = 0; j < 8; j++){
					let item = document.getElementById((''+i)+j)
					let team = board[i][j].team
					let piece = board[i][j].piece
					let normal = ["pawn","rook","knight","king","queen","bishop","square"]
					if(((i%2)-(j%2)) == 0){
						item.style.backgroundColor = "grey"
					}
					else{
						item.style.backgroundColor = "rgb(235, 235, 235)"
					}
					item.style.color = "black"
					if(!(board[i][j].frozen == 0)){
						item.style.backgroundColor = 'blue'
					}
					if(normal.includes(piece)){
						if(piece == "pawn"){
							piece = 6
						}
						else if(piece == "rook"){
							piece = 3
						}
						else if(piece == "knight"){
							piece = 5
						}
						else if(piece == "bishop"){
							piece = 4
						}
						else if(piece == "king"){
							piece = 1
						}
						else if(piece == "queen"){
							piece = 2
						}
						if(piece == "square") {
							item.innerHTML = '';
						}
						else {
							unicode = ((9811+(piece))+(6*(((board[i][j].team)-1)/-2)))
							item.innerHTML = '&#'+unicode+';';
						}
					}
					else{
						if(piece == "circus"){
							if(team == 1){
								item.innerHTML = '&#9828;';
							}
							else{
								item.innerHTML = '&#9824;';
							}
						}
						else if(piece == "wizard"){
							item.innerHTML = '&#10699;'
							if(team == 1){
								item.style.color = 'white'
							}
						}
						else if(piece == "paladin"){
							item.innerHTML = '&#167;'
						}
					}
				}
			}
		}
		function graphics(change){
			for(let i = 0; i < 8; i++){
				for(let j = 0; j < 8; j++){
					let item = document.getElementById((''+i)+j)
					document.body.classList.remove('dark-mode')
					if(item.classList.contains(change)){
						item.className = ''
					}
					else{
						item.className = ''
						if(change == 'rgb'){
							item.classList.add('gamer-mode')
							//needs to add 'gamer-mode' because rgb doesn't work without it
						}
						if(change == 'checker'){
							if(((i%2)-(j%2)) == 0){
								item.classList.add('checker')
							}
							else{
								item.classList.add('blank')
							}
						}
						else if(change == 'dark-mode'){
							document.body.classList.add('dark-mode')
							item.classList.add(change)
						}
						else{
							item.classList.add(change)
						}
					}
				}
			}
		}
		reset(true)
		whiteTurn = 1
		graphics('checker')
		graphicDraw()
	</script>
	<style>
		@keyframes rgbcolors {
			0% {background: #ee6055;}
			25% {background: #60d394;}
			50% {background: #aaf683;}
			75% {background: #ffd97d;}
			100% {background: #ff9b85;}
		}
		.grid-item {
			transition-timing-function:linear;
			background-color:none;
			transition:background-color 0.5s;
			color:black;
			background-image:none;
		}
		.grid-item:hover {
			background-color:lime;
		}
		[data-x='0'].gamer-mode {
			background-image: linear-gradient(to right,rgb(204,0,1),rgb(251,148,11));
		}
		[data-x='1'].gamer-mode {
			background-image: linear-gradient(to right,rgb(251,148,11),rgb(255,255,1));
		}
		[data-x='2'].gamer-mode {
			background-image: linear-gradient(to right,rgb(255,255,1),rgb(1,204,0));
		}
		[data-x='3'].gamer-mode {
			background-image: linear-gradient(to right,rgb(1,204,0),rgb(3,192,198));
		}
		[data-x='4'].gamer-mode {
			background-image: linear-gradient(to right,rgb(3, 192, 198),rgb(0,0,254));
		}
		[data-x='5'].gamer-mode {
			background-image: linear-gradient(to right,rgb(0,0,254),rgb(118,44,167));
		}
		[data-x='6'].gamer-mode {
			background-image: linear-gradient(to right,rgb(118,44,167),rgb(254,152,191));
		}
		[data-x='7'].gamer-mode {
			background-image: linear-gradient(to right,rgb(254,152,191),rgb(204,0,1));
		}
		.rgb{
			animation-name: rgbcolors;
			animation-duration: 10s;
			animation-iteration-count: infinite;
			animation-direction: alternate;
		}
		.dark-mode {
			background-color:black;
			color:white;
		}
		.checker {
			background-color:gray;
		}
		.blank {
			background-color:rgb(235, 235, 235);
		}
	</style>
</body>